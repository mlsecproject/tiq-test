---
title: "Measuring the IQ of your Threat Intelligence - Summer 2014"
author: "Alex Pinto & Kyle Maxwell"
date: "August 5, 2014"
output: html_document
---

This is the companion R Markdown document to the following presentations that
were delivered in Summer 2014:

* BSides LV 2014 - "Measuring the IQ of your threat intelligence feeds"
* DEF CON 22 - "Measuring the IQ of your threat intelligence feeds"

It should provide enough examples for usage of the tools implemented in this
repository.

Adding the TIQ-TEST functions
```{r, message=FALSE}
source("tiq-test.R")
```

## Acessing the data using TIQ-TEST

We can use the `tiq.data` functions to load the Threat Intelligence datasets from
the database for exploration using R. We have defaulted to the use of `data.table`
objects for this because they are faster and you can write tighter code around it
(sorry Hadleyverse fans).

We have roughly a month of data available on this public dataset:
```{r, message=FALSE}
.tiq.data.getAvailableDates("raw", "public_outbound")
```

This is an example of "RAW" (not enriched) outbound data imported from combine output
```{r, message=FALSE}
outbound.ti = tiq.data.loadTI("raw", "public_outbound", "20140701")
outbound.ti[, list(entity, type, direction, source, date)]
```

This specific outbound dataset has the following sources included:

```{r, message=FALSE}
outbound.ti = tiq.data.loadTI("raw", "public_outbound", "20140701")
unique(outbound.ti$source)
```

We can do the same for the inbound data we have to see the sources we have available:
```{r, message=FALSE}
inbound.ti = tiq.data.loadTI("raw", "public_inbound", "20140701")
unique(inbound.ti$source)
```

SIDE NOTE: please don't add non-malicious domains to malware domain lists, ok? :)

```{r, message=FALSE}
outbound.ti = tiq.data.loadTI("raw", "public_outbound", "20140701")
outbound.ti[entity %like% "google.com", list(entity, type, direction, source, date)] 
```

We can use the same `loadTI` function to also gather the enriched datasets:
```{r, message=FALSE}
enrich.ti = tiq.data.loadTI("enriched", "public_outbound", "20140710")
enrich.ti = enrich.ti[, notes := NULL]
enrich.ti[c(2,22264, 22266)]
```

## Novelty Test

The novelty test should be used to try get a sense of the ratio of new indicators
and the retiring of old ones as the data feeds progresses day-by-day.

There is no intrinsic right or wrong, but less frequent updates usually means 
that they are carefully curated (or abandoned :) ). Curated is great, abandoned
is very bad.

Here are some results of running the Novelty test on the inbound data:

```{r, fig.height=10, fig.width=10, fig.align='center'}
inbound.novelty = tiq.test.noveltyTest("public_inbound", "20140615", "20140715", 
                                select.sources=c("alienvault", "blocklistde", 
                                                 "dshield", "charleshaley"))
tiq.test.plotNoveltyTest(inbound.novelty)
```

And results running on the outbound date:

```{r, fig.height=10, fig.width=10, fig.align='center'}
outbound.novelty = tiq.test.noveltyTest("public_outbound", "20140615", "20140715", 
                                select.sources=c("alienvault", "malwaregroup", 
                                                 "malwaredomainlist", "malwaredomains"))
tiq.test.plotNoveltyTest(outbound.novelty)
```

## Overlap Test

This is an example of applying the Overlap Test to our inbound dataset
```{r, fig.height=10, fig.width=10, fig.align='center'}
  overlap = tiq.test.overlapTest("public_inbound", "20140715", "enriched", 
                                 select.sources=NULL)
  overlap.plot = tiq.test.plotOverlapTest(overlap, title="Overlap Test - Inbound Data - 20140715")
  print(overlap.plot)
```

Similarly, an example applying the Overlap Test to the outbound dataset
```{r, fig.height=10, fig.width=10, fig.align='center'}
  overlap = tiq.test.overlapTest("public_outbound", "20140715", "enriched", 
                                 select.sources=NULL)
  overlap.plot = tiq.test.plotOverlapTest(overlap, title="Overlap Test - Outbound Data - 20140715")
  print(overlap.plot)
```

What about that day when `malwaredomainlist` and `malwaredomains` moved together on the novelty test?
```{r, fig.height=10, fig.width=10, fig.align='center'}
  overlap = tiq.test.overlapTest("public_outbound", "20140628", "enriched", 
                                 select.sources=c("alienvault", "malwaredomainlist",
                                                  "malwaredomains", "zeus"))
  overlap.plot = tiq.test.plotOverlapTest(overlap, title="Overlap Test - Outbound Data Sources - 20140628")
  print(overlap.plot)
```

## Population Test Examples (Plots)

```{r}
  group = "public_outbound"
  pop.id = "country"
  pop.group = "mmgeo"
  end.date = "20140711"

  pop = tiq.test.extractPopulationFromTI(group, "country", end.date,
                                         select.sources=NULL)
  tiq.test.plotPopulationBars(pop, "country")

  pop = tiq.test.extractPopulationFromTI(group, c("asnumber", "asname"), end.date,
                                         select.sources=NULL)
  tiq.test.plotPopulationBars(pop, "asname")

  pop = tiq.test.extractPopulationFromTI(group, c("asnumber", "asname"), end.date,
                                         select.sources=NULL,
                                         split.ti=FALSE)
  pop.mm = tiq.data.loadPopulation("mmasn", c("asnumber", "asname"))
  tiq.test.plotPopulationBars(c(pop, pop.mm), "asname")

  pop = tiq.test.extractPopulationFromTI("public_inbound", "country", end.date,
                                         select.sources=NULL,
                                         split.ti=FALSE)
  pop.mm = tiq.data.loadPopulation("mmgeo", "country")
  tiq.test.plotPopulationBars(c(pop, pop.mm), "country")
```

## Population Test Examples (Inference - Country)

```{r}
  group = "public_outbound"
  pop.group = "mmgeo"
  end.date = "20140711"
  end.date2 = "20140712"

  pop = tiq.test.extractPopulationFromTI(group, "country", end.date,
                                         select.sources=NULL,
                                         split.ti=FALSE)

  pop2 = tiq.test.extractPopulationFromTI(group, "country", end.date2,
                                       select.sources=NULL,
                                       split.ti=FALSE)
  pop.mm = tiq.data.loadPopulation("mmgeo", "country")
```

Comparing the population from day X to day X+1

```{r}
ref.pop = pop$public_outbound
test.pop = pop2$public_outbound

tests = tiq.test.populationInference(ref.pop, test.pop, "country",
                                     exact = F, top=-1)

tests[p.value < 0.05 & conf.int.end > 0][order(conf.int.end, decreasing=T)]
tests[p.value < 0.05 & conf.int.start < 0][order(conf.int.start, decreasing=F)]
tests[p.value > 0.05]
```

Comparing the population from day X to the "true" population

```{r, cache=TRUE}
ref.pop = pop.mm$mmgeo
test.pop = pop2$public_outbound

tests = tiq.test.populationInference(ref.pop, test.pop, "country",
                                     exact = F, top=-1)

tests[p.value < 0.05 & conf.int.end > 0][order(conf.int.end, decreasing=T)]
tests[p.value < 0.05 & conf.int.start < 0][order(conf.int.start, decreasing=F)]
tests[p.value > 0.05]
```

## Population Test Examples (Inference - ASN)

```{r, cache=TRUE}
  group = "public_outbound"
  pop.id = "asname"
  pop.group = "mmasn"
  end.date = "20140711"
  end.date2 = "20140712"

  pop = tiq.test.extractPopulationFromTI(group, pop.id, end.date,
                                         select.sources=NULL,
                                         split.ti=FALSE)

  pop2 = tiq.test.extractPopulationFromTI(group, pop.id, end.date2,
                                          select.sources=NULL,
                                          split.ti=FALSE)
  pop.mm = tiq.data.loadPopulation(pop.group, pop.id)

    ref.pop = pop.mm$mmasn
    test.pop = pop$public_outbound

    tests = tiq.test.populationInference(ref.pop, test.pop, pop.id,
                                         exact = TRUE, top=-1)

  tests[p.value < 0.05 & conf.int.end > 0][order(conf.int.end, decreasing=T)]
  tests[p.value < 0.05 & conf.int.start < 0][order(conf.int.start, decreasing=F)]
  tests[p.value > 0.05]

  ref.pop = pop$public_outbound
  test.pop = pop2$public_outbound

  tests = tiq.test.populationInference(ref.pop, test.pop, pop.id,
                                       exact = F, top=-1)

  tests[p.value < 0.05 & conf.int.end > 0][order(conf.int.end, decreasing=T)]
  tests[p.value < 0.05 & conf.int.start < 0][order(conf.int.start, decreasing=F)]
  tests[p.value > 0.05]
```
